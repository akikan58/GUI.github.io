<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>作業開始</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="start-work.css"> 
</head>
<body>
    
    <div class="header-band">
        <div class="date-time-display">作業開始</div>
    </div>
    
    <div class="grid-container">
        
        <div class="grid-item queue-management-container">
            <h1>新しい作業を追加</h1>

            <div class="input-group">
                <label for="task-name" class="input-label">タスク名:</label>
                <input type="text" id="task-name" class="input-field" placeholder="例: A製品の製函">
            </div>

            <div class="input-group">
                <label for="box-count" class="input-label">製函する段ボールの枚数:</label>
                <div class="slider-container">
                    <input type="range" id="box-count" min="1" max="100" value="10" class="slider">
                    <span id="box-count-display" class="text-xl font-semibold text-gray-700">10枚</span>
                </div>
            </div>

            <div class="input-group flex items-center gap-4">
                <input type="checkbox" id="notification-toggle" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                <label for="notification-toggle" class="input-label mb-0">作業終了時に通知する</label>
            </div>

            <button id="add-to-queue-button" class="add-to-queue-button">
                <i class="fas fa-plus-circle mr-2"></i> キューに追加
            </button>
        </div>

        <div class="grid-item work-queue-list-container">
            <h1>現在の作業キュー</h1>
            <div id="work-queue-list" class="queue-list">
                <p>現在、キューに作業はありません。</p>
            </div>
            <div class="estimated-time">
                予想残り時間: <span id="remaining-time">00:00:00</span>
            </div>
        </div>

        <div class="back-to-home-button-container">
            <button id="back-to-home-button" class="interactive-button back-button">
                <i class="fas fa-shield-alt"></i> ホームに戻る
            </button>
        </div>
    </div>

    <div id="custom-modal" class="custom-modal hidden">
        <div class="custom-modal-content">
            <p id="modal-message" class="custom-modal-message"></p>
            <div id="modal-buttons" class="custom-modal-buttons">
                <button id="modal-ok-button" class="custom-modal-button custom-modal-ok">OK</button>
                <button id="modal-cancel-button" class="custom-modal-button custom-modal-cancel hidden">キャンセル</button>
            </div>
        </div>
    </div>
    
    <script>
        // カスタムアラート/確認ダイアログの表示関数
        function showCustomModal(message, type = 'alert') {
            return new Promise((resolve) => {
                const modal = document.getElementById('custom-modal');
                const modalMessage = document.getElementById('modal-message');
                const okButton = document.getElementById('modal-ok-button');
                const cancelButton = document.getElementById('modal-cancel-button');

                modalMessage.textContent = message;
                modal.classList.remove('hidden');

                if (type === 'confirm') {
                    cancelButton.classList.remove('hidden');
                } else {
                    cancelButton.classList.add('hidden');
                }

                okButton.onclick = () => {
                    modal.classList.add('hidden');
                    resolve(true);
                };

                cancelButton.onclick = () => {
                    modal.classList.add('hidden');
                    resolve(false);
                };
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            const boxCountSlider = document.getElementById('box-count');
            const boxCountDisplay = document.getElementById('box-count-display');
            const addToQueueButton = document.getElementById('add-to-queue-button');
            const workQueueList = document.getElementById('work-queue-list');
            const taskNameInput = document.getElementById('task-name');
            const notificationToggle = document.getElementById('notification-toggle');
            const remainingTimeDisplay = document.getElementById('remaining-time');
            const backToHomeButton = document.getElementById('back-to-home-button');

            let workQueue = []; // 作業キューを保持する配列
            let totalEstimatedTime = 0; // 全体の予想残り時間 (秒)
            let timerInterval; // タイマーのインターバルID

            // スライダーの値が変更されたときに表示を更新
            boxCountSlider.addEventListener('input', () => {
                boxCountDisplay.textContent = `${boxCountSlider.value}枚`;
            });

            // キューにアイテムを追加する関数
            addToQueueButton.addEventListener('click', async () => {
                const taskName = taskNameInput.value.trim();
                const boxCount = parseInt(boxCountSlider.value);
                const notifyOnCompletion = notificationToggle.checked;

                if (!taskName) {
                    await showCustomModal('タスク名を入力してください。', 'alert');
                    return;
                }

                // サンプル作業時間計算 (1枚あたり5秒とする)
                const estimatedTaskTime = boxCount * 5; // 秒

                const newItem = {
                    id: Date.now(), // ユニークなID
                    name: taskName,
                    boxCount: boxCount,
                    notify: notifyOnCompletion,
                    estimatedTime: estimatedTaskTime, // 秒
                    remainingTime: estimatedTaskTime, // 残り時間 (秒)
                    completed: false
                };

                workQueue.push(newItem);
                renderQueue();
                updateTotalEstimatedTime();

                // 入力フィールドをリセット
                taskNameInput.value = '';
                boxCountSlider.value = 10;
                boxCountDisplay.textContent = '10枚';
                notificationToggle.checked = false;

                await showCustomModal('キューに作業が追加されました！', 'alert');

                // キューにアイテムが追加されたらタイマーを開始
                if (!timerInterval) {
                    startTimer();
                }
            });

            // キューをレンダリングする関数
            function renderQueue() {
                workQueueList.innerHTML = ''; // 一度クリア
                if (workQueue.length === 0) {
                    workQueueList.innerHTML = '<p>現在、キューに作業はありません。</p>';
                    return;
                }

                workQueue.forEach(item => {
                    const queueItemDiv = document.createElement('div');
                    // スタイルクラスはstart-work.cssで定義されたものを適用
                    queueItemDiv.classList.add('queue-item'); 
                    if (item.completed) {
                        queueItemDiv.classList.add('completed');
                    }

                    const detailsDiv = document.createElement('div');
                    detailsDiv.classList.add('queue-item-details');
                    detailsDiv.innerHTML = `
                        <p class="font-bold">${item.name} (${item.boxCount}枚)</p>
                        <p class="text-sm">予想時間: ${formatTime(item.estimatedTime)}</p>
                        <p class="text-sm">残り時間: <span id="item-remaining-time-${item.id}">${formatTime(item.remainingTime)}</span></p>
                        ${item.notify ? '<p class="text-xs"><i class="fas fa-bell"></i> 通知あり</p>' : ''}
                    `;
                    queueItemDiv.appendChild(detailsDiv);

                    const actionsDiv = document.createElement('div');
                    actionsDiv.classList.add('queue-item-actions');

                    if (!item.completed) {
                        const completeButton = document.createElement('button');
                        completeButton.classList.add('complete-button');
                        completeButton.textContent = '完了';
                        completeButton.addEventListener('click', async () => {
                            const confirmed = await showCustomModal(`${item.name} を完了しますか？`, 'confirm');
                            if (confirmed) {
                                item.completed = true;
                                if (item.notify) {
                                    // 実際の通知処理 (ElectronのIPC経由など)
                                    if (typeof electronAPI !== 'undefined' && electronAPI.onShowAlert) {
                                        electronAPI.onShowAlert(null, `${item.name} が完了しました！`);
                                    } else {
                                        console.log(`${item.name} が完了しました！ (通知機能なし)`);
                                    }
                                }
                                renderQueue();
                                updateTotalEstimatedTime();
                            }
                        });
                        actionsDiv.appendChild(completeButton);
                    }

                    const deleteButton = document.createElement('button');
                    deleteButton.classList.add('delete-button');
                    deleteButton.textContent = '削除';
                    deleteButton.addEventListener('click', async () => {
                        const confirmed = await showCustomModal(`${item.name} をキューから削除しますか？`, 'confirm');
                        if (confirmed) {
                            workQueue = workQueue.filter(queueItem => queueItem.id !== item.id);
                            renderQueue();
                            updateTotalEstimatedTime();
                            if (workQueue.length === 0) {
                                stopTimer();
                            }
                        }
                    });
                    actionsDiv.appendChild(deleteButton);

                    queueItemDiv.appendChild(actionsDiv);
                    workQueueList.appendChild(queueItemDiv);
                });
            }

            // 時間をHH:MM:SS形式にフォーマットする関数
            function formatTime(seconds) {
                const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
                const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
                const s = String(seconds % 60).padStart(2, '0');
                return `${h}:${m}:${s}`;
            }

            // 全体の予想残り時間を更新する関数
            function updateTotalEstimatedTime() {
                totalEstimatedTime = workQueue.reduce((sum, item) => sum + (item.completed ? 0 : item.remainingTime), 0);
                remainingTimeDisplay.textContent = formatTime(totalEstimatedTime);

                // index.htmlの残り時間表示も更新 (この画面では不要だが、互換性のために残す)
                const currentTaskTimeElement = document.getElementById('current-task-time');
                if (currentTaskTimeElement) {
                    const firstUncompletedTask = workQueue.find(item => !item.completed);
                    if (firstUncompletedTask) {
                        currentTaskTimeElement.textContent = formatTime(firstUncompletedTask.remainingTime);
                    } else {
                        currentTaskTimeElement.textContent = '--:--:--';
                    }
                }
            }

            // タイマーを開始する関数
            function startTimer() {
                if (timerInterval) return;

                timerInterval = setInterval(() => {
                    let activeTaskFound = false;
                    for (let i = 0; i < workQueue.length; i++) {
                        if (!workQueue[i].completed) {
                            workQueue[i].remainingTime--;
                            if (workQueue[i].remainingTime <= 0) {
                                workQueue[i].remainingTime = 0;
                                workQueue[i].completed = true;
                                if (workQueue[i].notify) {
                                    if (typeof electronAPI !== 'undefined' && electronAPI.onShowAlert) {
                                        electronAPI.onShowAlert(null, `${workQueue[i].name} が時間になりました！`);
                                    } else {
                                        console.log(`${workQueue[i].name} が時間になりました！ (通知機能なし)`);
                                    }
                                }
                            }
                            activeTaskFound = true;
                            break;
                        }
                    }

                    renderQueue();
                    updateTotalEstimatedTime();

                    if (!activeTaskFound && workQueue.every(item => item.completed)) {
                        stopTimer();
                        showCustomModal('全ての作業が完了しました！', 'alert');
                    }
                }, 1000);
            }

            // タイマーを停止する関数
            function stopTimer() {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 初期レンダリング
            renderQueue();
            updateTotalEstimatedTime();

            // メインプロセスからのメッセージを受信してアラート表示
            if (typeof electronAPI !== 'undefined' && electronAPI.onShowAlert) {
                electronAPI.onShowAlert((event, message) => {
                    showCustomModal(message, 'alert');
                });
            }

            // ホームに戻るボタンのクリックイベント
            backToHomeButton.addEventListener('click', () => {
                if (typeof electronAPI !== 'undefined' && electronAPI.navigateTo) {
                    electronAPI.navigateTo('index');
                }else{
                    location.href = 'index.html';
                }
            });
        });
    </script>
</body>
</html>
